import fs from 'node:fs';
import fsPromises from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import { AGENTS, LOCKS } from './agents.mjs';

async function detect({ cwd, onUnknown } = {}) {
  let agent;
  let version;
  const lockPath = await findUp(Object.keys(LOCKS), { cwd });
  let packageJsonPath;
  if (lockPath)
    packageJsonPath = path.resolve(lockPath, "../package.json");
  else
    packageJsonPath = await findUp("package.json", { cwd });
  if (packageJsonPath && fs.existsSync(packageJsonPath)) {
    try {
      const pkg = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
      if (typeof pkg.packageManager === "string") {
        const [name, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
        version = ver;
        if (name === "yarn" && Number.parseInt(ver) > 1) {
          agent = "yarn@berry";
          version = "berry";
        } else if (name === "pnpm" && Number.parseInt(ver) < 7) {
          agent = "pnpm@6";
        } else if (AGENTS.includes(name)) {
          agent = name;
        } else {
          onUnknown?.(pkg.packageManager);
        }
      }
    } catch {
    }
  }
  if (!agent && lockPath)
    agent = LOCKS[path.basename(lockPath)];
  return { agent, version };
}
async function findUp(name, { cwd }) {
  let directory = path.resolve(cwd ?? process.cwd());
  const { root } = path.parse(directory);
  const names = [name].flat();
  while (directory && directory !== root) {
    for (const name2 of names) {
      const filePath = path.join(directory, name2);
      try {
        const stats = await fsPromises.stat(filePath);
        if (stats.isFile()) {
          return filePath;
        }
      } catch {
      }
    }
    directory = path.dirname(directory);
  }
}

export { AGENTS, LOCKS, detect };
